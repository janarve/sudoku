<!DOCTYPE html>
<html>
<head>
<script>

function areSetsEqual(a, b)
{
    return a.size === b.size && [...a].every(value => b.has(value))
}

function uniteSets(s1, s2)
{
    let rs = new Set(s1)
    for (const v of s2) {
        rs.add(v)
    }
    return rs
}

function subtractSets(s1, s2)
{
    let rs = new Set(s1)
    for (const v of s2) {
        rs.delete(v)
    }
    return rs
}

/*
var input = [0,0,0, 6,0,0, 0,9,7,
             5,0,0, 2,0,0, 0,0,3,
             0,0,0, 0,0,1, 5,0,0,

             0,0,0, 0,0,4, 1,0,0,
             0,0,4, 0,2,0, 0,0,0,
             2,7,0, 0,1,0, 8,0,5,

             0,0,9, 0,0,0, 0,0,0,
             0,0,0, 3,0,0, 7,5,0,
             6,1,3, 0,7,0, 0,0,0
]

var input = [0,0,0, 0,0,0, 0,0,0,
             0,0,0, 0,0,0, 0,0,0,
             0,0,0, 0,0,0, 0,0,0,

             0,0,0, 0,0,0, 0,0,0,
             0,0,0, 0,0,0, 0,0,0,
             0,0,0, 0,0,0, 0,0,0,

             0,0,0, 0,0,0, 0,0,0,
             0,0,0, 0,0,0, 0,0,0,
             0,0,0, 0,0,0, 0,0,0
]
*/

var input = [0,8,3, 0,2,0, 7,1,0,
             1,0,0, 0,8,0, 0,0,3,
             0,9,0, 7,3,1, 0,4,8,

             7,5,0, 0,9,2, 4,0,1,
             0,0,0, 4,0,0, 0,5,0,
             9,4,0, 0,1,0, 6,0,0,

             0,0,0, 0,0,0, 0,0,0,
             0,0,5, 2,4,0, 0,0,0,
             0,6,0, 0,5,0, 8,7,0
]

var board = {
    cell: function (x, y) {
        return this.cells[9*y + x]
    },
    removeFrom9: function (x, y, xc, yc, num)
    {
        let yend = y + yc
        let xend = x + xc
        for (let yy = y; yy < yend; ++yy) {
            for (let xx = x; xx < xend; ++xx) {
                let cel = this.cell(xx, yy)
                this.removeFromCell(cel, num)
            }
        }
    },
    get9Cells: function(x, y, xc) {
        if (xc != 1 && xc != 3 && xc != 9)
            console.assert('xc:', xc)
        let yc = 9/xc
        let res = []
        let yend = y + yc
        let xend = x + xc
        for (let yy = y; yy < yend; ++yy) {
            for (let xx = x; xx < xend; ++xx) {
                let cel = this.cell(xx, yy)
                res.push(cel)
            }
        }
        return res
    },
    removeFromCell: function(cel, num) {
        cel.candidates.delete(num)
    },
    cells: []
}

for (let c = 0; c < input.length; ++c) {
    let s = new Set()
    for (let c = 1; c <= 9; ++c) {
        s.add(c)
    }
    var entry = {}
    entry.n = input[c]
    entry.candidates = s
    board.cells.push(entry)
}

function getCandidates(x, y)
{
    let arr = []
    let s = board.cell(x,y).candidates
    return s
}

function removeCandidateFromCells(cells, num)
{
    for (let i = 0; i < cells.length; ++i) {
        let cel = cells[i]
        cel.candidates.delete(num)
    }
}

function removeObviousCandidates()
{
    let changed = true
    for (let y = 0; y < 9; ++y) {
        for (let x = 0; x < 9; ++x) {
            let cel = board.cell(x, y)
            if (cel.n > 0) {
                let xr = Math.floor(x/3)*3
                let yr = Math.floor(y/3)*3
                board.removeFrom9(xr, yr, 3, 3, cel.n)
                board.removeFrom9(0, y, 9, 1, cel.n)
                board.removeFrom9(x, 0, 1, 9, cel.n)
            }
        }
    }
    return changed
}

function solve_reduceNotPartOfCluster()
{
    let changed = false
    // rows
    for (let y = 0; y < 9; ++y) {
        let cells = board.get9Cells(0, y, 9)
        changed = solve9Series_reduceNotPartOfCluster(cells)
    }

    // columns
    for (let x = 0; x < 9; ++x) {
        let cells = board.get9Cells(x, 0, 1)
        changed = solve9Series_reduceNotPartOfCluster(cells)
    }

    // 3x3 subgrids
    for (let x = 0; x < 9; x+=3) {
        for (let y = 0; y < 9; y+=3) {
            let cells = board.get9Cells(x, y, 3)
            changed = solve9Series_reduceNotPartOfCluster(cells)
        }
    }

    return changed

}

/*
next reducer: if a number exist only in *one* row of a 3x3 grid,
remove the same number from the rest of the 1x9 row
*/

function solve9Series_reduceNotPartOfCluster(cells)
{
    let changed = false
    let indicesToInclude = []
    for (let i = 0; i < cells.length; ++i) {
        let cell = cells[i]
        if (cell.n === 0) {
            indicesToInclude.push(i)
        }
    }

    let combs = getCombinations(indicesToInclude)
    for (let i = 0; i < combs.length; ++i) {
        let order = combs[i]
        if (order.length >= 2) {
            let s = new Set()
            for (let j = 0; j < order.length; ++j) {
                let n = order[j]
                let cell = cells[n]
                s = uniteSets(s, cell.candidates)
            }
            if (s.size === order.length) {
                for (let c = 0; c < cells.length; c++) {
                    let cell = cells[c]
                    if (cell.n === 0 && !order.includes(c)) {
                        cell.candidates = subtractSets(cell.candidates, s)
                    }
                }
            }
        }
    }
    return changed
}

function solve_singleNumber()
{
    let changed = false
    for (let y = 0; y < 9; ++y) {
        for (let x = 0; x < 9; ++x) {
            let cel = board.cell(x, y)
            let cands = cel.candidates
            if (cel.n === 0 && cands.size === 1) {
                cel.n = cands.values().next().value
                removeObviousCandidates()
                changed = true
            }
        }
    }
    return changed
}

function solve9Series_uniqueNumber(cells)
{
    let changed = false
    arr = []
    arr.length = 10
    arr.fill(0)
    for (let i = 0; i < cells.length; ++i) {
        let cel = cells[i]
        if (cel.n === 0) {
            let cands = cel.candidates

            const cands_it = cands.entries();
            for (const cand of cands_it) {
                let n = cand[0]
                arr[n] = arr[n] + 1
            }
        }
    }
    for (let n = 1; n < 10; ++n) {
        if (arr[n] === 1) {
            for (let i = 0; i < 9; ++i) {
                let cel = cells[i]
                if (cel.n === 0 && cel.candidates.has(n)) {
                    cel.n = n
                    removeObviousCandidates()
                    changed = true
                }
            }
        }
    }
    return changed
}

// If there is only one cell in a series holding that unique number, that cell must have that number
function solve_uniqueNumbers()
{
    let changed = false
    // rows
    for (let y = 0; y < 9; ++y) {
        let cells = board.get9Cells(0, y, 9)
        changed = solve9Series_uniqueNumber(cells)
    }

    // columns
    for (let x = 0; x < 9; ++x) {
        let cells = board.get9Cells(x, 0, 1)
        changed = solve9Series_uniqueNumber(cells)
    }

    // 3x3 subgrids
    for (let x = 0; x < 9; x+=3) {
        for (let y = 0; y < 9; y+=3) {
            let cells = board.get9Cells(x, y, 3)
            changed = solve9Series_uniqueNumber(cells)
        }
    }


    return changed
}

function solve9Series_reducePairNumber(cells)
{
    let changed = false
    for (let i = 0; i < cells.length; ++i) {
        let cel = cells[i]
        if (cel.n === 0) {
            for (let j = i + 1; j < cells.length; ++j) {
                let cel_j = cells[j]
                if (cel_j.n === 0) {
                    if (cel.candidates.size === 2 && areSetsEqual(cel.candidates, cel_j.candidates)) {
                        let cands_it = cel.candidates.values()
                        let n1 = cands_it.next().value
                        let n2 = cands_it.next().value
                        let slic1 = cells.slice(0, i)
                        let slic2 = cells.slice(i + 1, j)
                        let slic3 = cells.slice(j + 1, cells.length)

                        removeCandidateFromCells(slic1, n1)
                        removeCandidateFromCells(slic1, n2)
                        removeCandidateFromCells(slic2, n1)
                        removeCandidateFromCells(slic2, n2)
                        removeCandidateFromCells(slic3, n1)
                        removeCandidateFromCells(slic3, n2)
                    }
                }
            }
        }
    }
}

// If there is only one cell in a series holding that unique number, that cell must have that number
function solve_reducePairNumbers()
{
    let changed = false
    // rows
    for (let y = 0; y < 9; ++y) {
        let cells = board.get9Cells(0, y, 9)
        changed = solve9Series_reducePairNumber(cells)
    }

    // columns
    for (let x = 0; x < 9; ++x) {
        let cells = board.get9Cells(x, 0, 1)
        changed = solve9Series_reducePairNumber(cells)
    }

    // 3x3 subgrids
    for (let x = 0; x < 9; x+=3) {
        for (let y = 0; y < 9; y+=3) {
            let cells = board.get9Cells(x, y, 3)
            changed = solve9Series_reducePairNumber(cells)
        }
    }


    return changed
}


function drawBoard()
{
    let table = document.getElementById('tabell')
    let tr_list = table.getElementsByTagName('tr')

    for (let y = 0; y < 9; ++y) {
        let tr = tr_list.item(y)
        let td_list = tr.getElementsByTagName('td')
        for (let x = 0; x < 9; ++x) {
            let td = td_list.item(x)
            let div_list = td.getElementsByTagName('div')
            for (let n = 0; n < 10; ++n) {
                let div = div_list.item(n)
                div.classList.add("hide")
            }
            let cell = board.cell(x,y)
            if (cell.n > 0) {
                let div = div_list.item(9)
                div.innerText = cell.n
                div.classList.remove("hide")
            } else {
                var cands = cell.candidates
                for (let n = 1; n <= 9; ++n) {
                    let div = div_list.item(n-1)
                    if (cands.has(n)) {
                        div.classList.remove("hide")
                    }
                }
            }
        }
    }
}

/*
  [1, 2, 5, 8]
  =>
  [ [1],   [2],   [5],   [8]]
    [1,2], [1,5], [1,8],
    [2,5], [2,8],
    [5,8],
    [1,2,5], [1,2,8], [1,5,8], [2,5,8],
    [1,2,5,8]
*/
function getCombinations(input)
{
    let combis = []
    let temp = []
    const numCombinations = Math.pow(2, input.length)

    for (let i = 1; i < numCombinations; i++)
    {
        comb = []
        let pow = 1
        for (let j = 0; j < input.length; j++)
        {
            if (i & pow)
                comb.push(input[j]);
            pow = pow * 2
        }
        combis.push(comb)
    }

    combis.sort((a, b) => a.length - b.length)
    return combis
}

function showCandidates()
{
    let table = document.getElementById('tabell')
    let tr_list = table.getElementsByTagName('tr')
    for (let y = 0; y < 9; ++y) {
        let tr = tr_list.item(y)
        let td_list = tr.getElementsByTagName('td')
        for (let x = 0; x < 9; ++x) {
            let td = td_list.item(x)
            td.addEventListener("click", cellClicked)
            for (let n = 1; n <= 9; ++n) {
                let div = document.createElement('div')
                div.innerHTML = '' + n

                if (n % 3 == 1)
                    div.classList.add("left")
                else if (n % 3 == 2)
                    div.classList.add("hcenter")
                else if (n % 3 == 0)
                    div.classList.add("right")

                if (n >= 7) {
                    div.classList.add("bottom")
                } else if (n >= 4) {
                    div.classList.add("vcenter")
                } else if (n >= 1) {
                    div.classList.add("top")
                }

                td.appendChild(div)
            }
            let div = document.createElement('div')
            div.classList.add("top")
            div.classList.add("bottom")
            div.classList.add("left")
            div.classList.add("right")
            div.classList.add("number")
            div.classList.add("hide")
            div.innerHTML = "0"
            td.appendChild(div)
        }
    }

    removeObviousCandidates()

    // update visualization of candidates and input numbers
    drawBoard()
}


var g_solveState = 0

function incrementalSolve()
{
    let subSolvers = [
        removeObviousCandidates,
        solve_reduceNotPartOfCluster,
        solve_singleNumber,
        removeObviousCandidates,
        solve_reduceNotPartOfCluster,
        solve_uniqueNumbers,
        solve_reducePairNumbers
    ]

    if (g_solveState >= subSolvers.length)
        g_solveState = 0
    subSolvers[g_solveState]()

    drawBoard()

    ++g_solveState
}

var selectedCellX = -1
var selectedCellY = -1
var punchCandidateMode = false

function toggleNumberPunchMode()
{
    punchCandidateMode = !punchCandidateMode

    let table = document.getElementById('tabell')
    if (punchCandidateMode) {
        table.classList.add('candidateMode')
    } else {
        table.classList.remove('candidateMode')
    }
}

function cellElement(x, y) {
    let table = document.getElementById('tabell')
    let tr_list = table.getElementsByTagName('tr')
    let tr = tr_list[y]
    let td_list = tr.getElementsByTagName('td')
    let td = td_list[x]
    return td
}

function cellClicked(mouseEvent) {
    if (selectedCellX >= 0) {
        let oldTD = cellElement(selectedCellX, selectedCellY)
        oldTD.classList.remove("selectedCell")
    }
    let td = mouseEvent.currentTarget
    td.classList.add("selectedCell")
    let x = 0
    let y = 0

    let table = document.getElementById('tabell')
    let tr_list = table.getElementsByTagName('tr')
    let keepGoing = true
    while (y < 9) {
        let tr = tr_list[y]
        if (tr === td.parentNode) {
            let td_list = tr.getElementsByTagName('td')
            for (x = 0; x < 9; ++x) {
                if (td_list[x] == td) {
                    selectedCellX = x
                    selectedCellY = y
                    keepGoing = false
                    break
                }
            }
        }
        if (!keepGoing)
            break
        ++y
    }
}
document.addEventListener("keydown", function(event) {
    event = event || window.event;
    let allowedKeys = "0123456789"
    if (allowedKeys.includes(event.key)) {
        if (punchCandidateMode) {
            event.preventDefault();
            if (selectedCellX >= 0 && selectedCellY >= 0) {
                let cel = board.cell(selectedCellX, selectedCellY)
                let n = parseInt(event.key)
                if (cel.candidates.has(n)) {
                    cel.candidates.delete(n)
                } else {
                    cel.candidates.add(n)
                }
                drawBoard()
            }
        } else {
            // Cancel the default action, if needed
            event.preventDefault();
            if (selectedCellX >= 0 && selectedCellY >= 0) {
                let cel = board.cell(selectedCellX, selectedCellY)
                cel.n = parseInt(event.key)
                drawBoard()
            }
        }
    } else if (event.key === 'm') {
        event.preventDefault();
        toggleNumberPunchMode()
    }

    let keyCode = parseInt(event.keyCode)
    if (keyCode >= 37 && keyCode <= 40) {
        event.preventDefault();
        let oldSelectedCellX = selectedCellX
        let oldSelectedCellY = selectedCellY
        if (selectedCellX === -1 || selectedCellY === -1) {
            selectedCellX = 0
            selectedCellY = 0
        } else {
             if (keyCode == 37) {
               // left arrow
               --selectedCellX
            } else if (keyCode == 38) {
                // up arrow
                --selectedCellY
            } else if (keyCode === 39) {
                // right arrow
                ++selectedCellX
            } else if (keyCode == 40) {
                // down arrow
                ++selectedCellY
            }
        }
        selectedCellX = Math.max(0, Math.min(selectedCellX, 8))
        selectedCellY = Math.max(0, Math.min(selectedCellY, 8))

        if (selectedCellX != oldSelectedCellX || selectedCellY != oldSelectedCellY) {
            if (oldSelectedCellX !== -1 && oldSelectedCellY !== -1) {
                let oldTD = cellElement(oldSelectedCellX, oldSelectedCellY)
                oldTD.classList.remove("selectedCell")
            }
            if (selectedCellX !== -1 && selectedCellY !== -1) {
                let newTD = cellElement(selectedCellX, selectedCellY)
                newTD.classList.add("selectedCell")
            }
        }
    }

})

</script>
<style>
table {
    border-collapse: collapse;
}

table tr td {
    width: 45px;
    height: 45px;
    position: relative;
}

/* more solid borders to indicate the 3x3 subgrid */
table tr td:nth-child(-3n + 6) {
    border-right: 3px solid;
}

table tr:nth-child(-3n + 6) td {
    border-bottom: 3px solid;
}

table tr td div {
    position:absolute;
    font-size: 10px;
}
input {
    width: 100%;
}
.left {
    left: 2px;
}

.hcenter {
  width: 100%;
  text-align: center;
}

.right {
    right: 2px;
}

.top {
    top: 2px;
}

.vcenter {
    top: 50%;
    -ms-transform: translateY(-50%);
    transform: translateY(-50%);
}

.bottom {
    bottom: 2px;
}

.hide {
    display: none;
}

.number {
    font-size: 18px;
    background-color: #a0ffa0;
}

.selectedCell {
    background-color: #ffff40;
}

.candidateMode {
    background-color: #e0e0ff;
}

</style>
</head>
<body onload="showCandidates()">
<table id=tabell border="1">
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>

<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>

<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</table>
<button onClick="incrementalSolve()">Solve</botton>
</body>
</html>




